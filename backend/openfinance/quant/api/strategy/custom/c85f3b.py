"""
能量-波动-筹码多因子策略 - Custom Strategy

融合能量因子（量价动能强度）、波动系数因子（价格波动率与风险调整收益比）和筹码分布因子（主力持仓集中度与成本结构健康度）的三维度多因子策略，通过等权重合成信号筛选优质标的，适用于A股市场中长期配置

Generated by AI Strategy Creator
"""

from typing import Optional
import pandas as pd
from openfinance.quant.strategy.base import (
    BaseStrategy,
    StrategyMetadata,
    StrategyType,
    WeightMethod,
    RebalanceFrequency,
)
from openfinance.quant.strategy.registry import register_strategy


@register_strategy
class C85f3bStrategy(BaseStrategy):
    """
    能量-波动-筹码多因子策略
    
    融合能量因子（量价动能强度）、波动系数因子（价格波动率与风险调整收益比）和筹码分布因子（主力持仓集中度与成本结构健康度）的三维度多因子策略，通过等权重合成信号筛选优质标的，适用于A股市场中长期配置
    """
    
    def _default_metadata(self) -> StrategyMetadata:
        return StrategyMetadata(
            strategy_id="strategy_______________c85f3b",
            name="能量-波动-筹码多因子策略",
            description="""融合能量因子（量价动能强度）、波动系数因子（价格波动率与风险调整收益比）和筹码分布因子（主力持仓集中度与成本结构健康度）的三维度多因子策略，通过等权重合成信号筛选优质标的，适用于A股市场中长期配置""",
            strategy_type=StrategyType.MULTI_FACTOR,
            factor_ids=['["factor_energy"', '"factor_volatility_coefficient"', '"factor_chip_distribution"]'],
            tags=['multi_factor'],
        )
    
    def generate_signals(self, data: dict[str, pd.DataFrame], factor_values: Optional[dict] = None, date=None) -> dict[str, float]:
        '''Generate trading signals.'''
        signals = {}
        
        if not factor_values:
            return signals
        
        # Combine factor signals with weights
        factor_weights = {}
        
        for factor_id, scores in factor_values.items():
            weight = factor_weights.get(factor_id, 1.0 / len(factor_values))
            for code, score in scores.items():
                signals[code] = signals.get(code, 0) + weight * score
        
        return signals
    
    def calculate_portfolio_weights(self, signals: dict[str, float], prices: pd.DataFrame, covariance_matrix=None) -> dict[str, float]:
        '''Calculate portfolio weights.'''
        sorted_signals = sorted(signals.items(), key=lambda x: x[1], reverse=True)
        top_n = min(50, len(sorted_signals))
        
        weights = {}
        for code, _ in sorted_signals[:top_n]:
            weights[code] = 1.0 / top_n
        
        return weights
