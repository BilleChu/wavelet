"""
chip_distribution_2y - Custom Factor

计算股票2年周期（约500个交易日）的筹码分布集中度，通过价格区间成交量加权分布的标准差倒数衡量筹码锁定程度；值越高表示筹码越集中在当前价格附近，主力控盘度越高
- 因子类型：technical
- 因子类别：liquidity
- 回看周期：500天

Generated by AI Factor Creator
"""

import numpy as np
from typing import Optional, List
from openfinance.datacenter.models.analytical import ADSKLineModel
from openfinance.quant.factors.base import (
    FactorBase,
    FactorMetadata,
    FactorType,
    FactorCategory,
)
from openfinance.quant.factors.registry import register_factor


@register_factor
class ChipDistribution2y20260219135836Factor(FactorBase):
    """
    chip_distribution_2y
    
    计算股票2年周期（约500个交易日）的筹码分布集中度，通过价格区间成交量加权分布的标准差倒数衡量筹码锁定程度；值越高表示筹码越集中在当前价格附近，主力控盘度越高
- 因子类型：technical
- 因子类别：liquidity
- 回看周期：500天
    """
    
    def _default_metadata(self) -> FactorMetadata:
        return FactorMetadata(
            factor_id="factor_chip_distribution_2y_20260219135836",
            name="chip_distribution_2y",
            description="""计算股票2年周期（约500个交易日）的筹码分布集中度，通过价格区间成交量加权分布的标准差倒数衡量筹码锁定程度；值越高表示筹码越集中在当前价格附近，主力控盘度越高
- 因子类型：technical
- 因子类别：liquidity
- 回看周期：500天""",
            factor_type=FactorType.CUSTOM,
            category=FactorCategory.LIQUIDITY,
            lookback_period=500,
            required_fields=["close", "high", "low", "volume"],
            tags=['liquidity', 'technical'],
            author="user",
        )
    
    def _calculate(self, klines: List[ADSKLineModel], **params) -> Optional[float]:
        """
        Calculate chip distribution concentration.
        
        筹码分布集中度计算方法：
        1. 将价格区间分成若干等份
        2. 计算每个价格区间的成交量加权分布
        3. 计算分布的标准差倒数作为集中度指标
        4. 值越高表示筹码越集中在当前价格附近
        """
        if not klines or len(klines) < self.metadata.lookback_period:
            return None
        
        close = np.array([k.close for k in klines])
        high = np.array([k.high for k in klines])
        low = np.array([k.low for k in klines])
        volume = np.array([k.volume for k in klines])
        
        period = params.get("period", self.metadata.lookback_period)
        num_bins = params.get("num_bins", 50)
        
        if len(close) < period:
            return None
        
        close = close[-period:]
        high = high[-period:]
        low = low[-period:]
        volume = volume[-period:]
        
        if np.sum(volume) == 0:
            return None
        
        price_min = np.min(low)
        price_max = np.max(high)
        
        if price_max <= price_min:
            return None
        
        bin_edges = np.linspace(price_min, price_max, num_bins + 1)
        chip_distribution = np.zeros(num_bins)
        
        for i in range(len(close)):
            daily_low = low[i]
            daily_high = high[i]
            daily_volume = volume[i]
            
            if daily_high <= daily_low:
                mid_price = (daily_high + daily_low) / 2
                bin_idx = min(int((mid_price - price_min) / (price_max - price_min) * num_bins), num_bins - 1)
                chip_distribution[bin_idx] += daily_volume
            else:
                price_range = daily_high - daily_low
                for j in range(num_bins):
                    bin_low = bin_edges[j]
                    bin_high = bin_edges[j + 1]
                    
                    overlap_low = max(daily_low, bin_low)
                    overlap_high = min(daily_high, bin_high)
                    
                    if overlap_high > overlap_low:
                        overlap_ratio = (overlap_high - overlap_low) / price_range
                        chip_distribution[j] += daily_volume * overlap_ratio
        
        total_volume = np.sum(chip_distribution)
        if total_volume == 0:
            return None
        
        chip_distribution = chip_distribution / total_volume
        
        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
        
        weighted_mean = np.sum(bin_centers * chip_distribution)
        weighted_variance = np.sum(chip_distribution * (bin_centers - weighted_mean) ** 2)
        weighted_std = np.sqrt(weighted_variance)
        
        price_range_normalized = (price_max - price_min) / close[-1]
        if weighted_std > 0:
            concentration = 1.0 / (weighted_std / close[-1] + 1e-10)
        else:
            concentration = 100.0
        
        concentration = min(concentration, 100.0)
        
        return float(concentration)
