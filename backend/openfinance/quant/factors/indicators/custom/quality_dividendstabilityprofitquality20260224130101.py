"""
持续分红与利润率质量复合因子（DividendStabilityProfitQualityFactor） - Custom Factor

综合评估企业分红持续性与盈利能力质量的复合基本面因子。通过计算近4期（一年）股息支付率（DPR）的稳定性（变异系数）与净利润率（Net Margin）、净资产收益率（ROE）的加权质量得分，形成风险调整后的“分红-盈利”双维质量指标。高值代表企业具备稳定、可持续的分红能力且盈利质量优良。
- 因子类型：multi_source（多源因子）
- 因子类别：quality（质量类因子）
- 回看周期：4（季度，对应最近4个财报期，即1年财务数据）
- 数据模型：ADSFinancialIndicatorModel, ADSCashFlowModel

Generated by AI Factor Creator
Data Models: ADSKLineModel, ADSFinancialIndicatorModel, ADSCashFlowModel, ADSMacroEconomicModel
"""

import numpy as np
from typing import Optional, List
from openfinance.datacenter.models.analytical import ADSKLineModel, ADSFinancialIndicatorModel, ADSCashFlowModel, ADSMacroEconomicModel
from openfinance.quant.factors.base import (
    FactorBase,
    FactorMetadata,
    FactorType,
    FactorCategory,
)
from openfinance.quant.factors.registry import register_factor


@register_factor
class QualityDividendstabilityprofitquality20260224130101Factor(FactorBase):
    """
    持续分红与利润率质量复合因子（DividendStabilityProfitQualityFactor）
    
    综合评估企业分红持续性与盈利能力质量的复合基本面因子。通过计算近4期（一年）股息支付率（DPR）的稳定性（变异系数）与净利润率（Net Margin）、净资产收益率（ROE）的加权质量得分，形成风险调整后的“分红-盈利”双维质量指标。高值代表企业具备稳定、可持续的分红能力且盈利质量优良。
- 因子类型：multi_source（多源因子）
- 因子类别：quality（质量类因子）
- 回看周期：4（季度，对应最近4个财报期，即1年财务数据）
- 数据模型：ADSFinancialIndicatorModel, ADSCashFlowModel
    """
    
    def _default_metadata(self) -> FactorMetadata:
        return FactorMetadata(
            factor_id="factor_持续分红与利润率quality复合因子_dividendstabilityprofitqualityfactor_20260224130101",
            name="持续分红与利润率质量复合因子（DividendStabilityProfitQualityFactor）",
            description="""综合评估企业分红持续性与盈利能力质量的复合基本面因子。通过计算近4期（一年）股息支付率（DPR）的稳定性（变异系数）与净利润率（Net Margin）、净资产收益率（ROE）的加权质量得分，形成风险调整后的“分红-盈利”双维质量指标。高值代表企业具备稳定、可持续的分红能力且盈利质量优良。
- 因子类型：multi_source（多源因子）
- 因子类别：quality（质量类因子）
- 回看周期：4（季度，对应最近4个财报期，即1年财务数据）
- 数据模型：ADSFinancialIndicatorModel, ADSCashFlowModel""",
            factor_type=FactorType.CUSTOM,
            category=FactorCategory.QUALITY,
            lookback_period=4,
            required_fields=['close', 'financial_data', 'cash_flow', 'macro'],
            tags=['quality', 'multi_source'],
            author="user",
        )
    
    def _calculate(self, klines: List[ADSKLineModel],
        financials: List[ADSFinancialIndicatorModel] = None,
        cash_flows: List[ADSCashFlowModel] = None,
        macro_data: List[ADSMacroEconomicModel] = None, **params) -> Optional[float]:
        '''Calculate factor value.'''
        period = params.get('period', 4)
        
        if not financials or not cash_flows or len(financials) < period or len(cash_flows) < period:
            return None
        
        financials_sorted = sorted(financials, key=lambda x: x.report_date, reverse=True)
        cash_flows_sorted = sorted(cash_flows, key=lambda x: x.report_date, reverse=True)
        
        fin_dates = {f.report_date: f for f in financials_sorted}
        cf_dates = {c.report_date: c for c in cash_flows_sorted}
        
        common_dates = sorted(list(fin_dates.keys() & cf_dates.keys()), reverse=True)
        if len(common_dates) < period:
            return None
        
        selected_dates = common_dates[:period]
        
        net_profits = []
        net_margins = []
        roes = []
        dividends_paid = []
        
        for date in selected_dates:
            fin = fin_dates[date]
            cf = cf_dates[date]
            
            if (fin.net_profit is None or fin.net_profit <= 0 or
                fin.net_margin is None or fin.roe is None):
                continue
            if cf.dividends_paid is None or cf.dividends_paid < 0:
                continue
            
            net_profits.append(fin.net_profit)
            net_margins.append(fin.net_margin)
            roes.append(fin.roe)
            dividends_paid.append(cf.dividends_paid)
        
        if len(net_profits) < 3:
            return None
        
        dpr_values = []
        for i in range(len(net_profits)):
            if net_profits[i] > 0:
                dpr = dividends_paid[i] / net_profits[i]
                if 0 <= dpr <= 1.5:
                    dpr_values.append(dpr)
        
        if len(dpr_values) < 3:
            return None
        
        dpr_array = np.array(dpr_values)
        dpr_mean = np.mean(dpr_array)
        dpr_std = np.std(dpr_array, ddof=1)
        
        if dpr_mean == 0:
            stability_score = 0.0
        else:
            cv = dpr_std / dpr_mean
            stability_score = 1.0 / (1.0 + cv)
            stability_score = max(0.0, min(2.0, stability_score))
        
        margin_array = np.array(net_margins)
        roe_array = np.array(roes)
        
        valid_mask = (~np.isnan(margin_array)) & (~np.isnan(roe_array)) & (margin_array != 0) & (roe_array != 0)
        if not np.any(valid_mask):
            return None
        
        valid_margins = margin_array[valid_mask]
        valid_roes = roe_array[valid_mask]
        
        if len(valid_margins) > 1 and len(valid_roes) > 1:
            margin_z = (valid_margins - np.mean(valid_margins)) / (np.std(valid_margins, ddof=1) + 1e-8)
            roe_z = (valid_roes - np.mean(valid_roes)) / (np.std(valid_roes, ddof=1) + 1e-8)
            quality_score = float(np.mean((margin_z + roe_z) / 2.0))
            quality_score = max(-1.5, min(1.5, quality_score))
        else:
            avg_margin = np.mean(valid_margins) if len(valid_margins) > 0 else 0.0
            avg_roe = np.mean(valid_roes) if len(valid_roes) > 0 else 0.0
            norm_margin = (avg_margin - 0.12) / 0.12 if 0.12 != 0 else 0.0
            norm_roe = (avg_roe - 0.10) / 0.10 if 0.10 != 0 else 0.0
            quality_score = float((norm_margin + norm_roe) / 2.0)
            quality_score = max(-1.5, min(1.5, quality_score))
        
        composite_score = 0.6 * stability_score + 0.4 * quality_score
        return float(composite_score)
